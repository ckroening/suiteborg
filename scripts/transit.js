// Generated by CoffeeScript 2.3.1
// Description:
//   Taps into the MetroTransit API to provide transit times
//
// Dependencies:
//   None
//
// Configuration:
//   None
//
// Commands:
//   hubot when is the next <route> (bus/train) heading <direction> from <stop/stop_id/intersection>
//
// Author:
//   Ryan

var MTC_API_URL, MTC_DIRECTIONS, MTC_ERROR_MESSAGE, MTC_NO_RESPONSE_MESSAGE, MTC_TRAINS, get_depart_time, get_depart_time_stopid, get_stop_code;

MTC_DIRECTIONS = {
  "north": "4",
  "south": "1",
  "east": "2",
  "west": "3"
};

MTC_API_URL = "http://svc.metrotransit.org/NexTrip/";

MTC_TRAINS = {
  "blue line": "901",
  "green line": "902",
  "red line": "903",
  "northstar": "888",
  "northstar link": "887",
  "st cloud link": "887"
};

MTC_ERROR_MESSAGE = "INSUFFICIENT DATA; YOU HAVE NOT BEEN ASSIMILATED. YET.";

MTC_NO_RESPONSE_MESSAGE = "TRANSIT IS IRRELEVANT. YOU WILL BE ASSIMILATED.";

get_stop_code = function(msg, route, direction, stop_string) {
  var direction_num, service_url, stop_code;
  direction_num = MTC_DIRECTIONS[direction];
  service_url = MTC_API_URL + "Stops/" + route + "/" + direction_num + "?format=JSON";
  console.log("get_stop_code request: " + service_url);
  stop_code = "";
  return msg.http(service_url).get()(function(err, res, body) {
    var i, len, results, results1, stop, stop_text;
    if (err || res.statusCode !== 200) {
      msg.reply(MTC_ERROR_MESSAGE + "(NexTrip response bad)");
      return;
    }
    results = JSON.parse(body);
    if (results.length === 0) {
      msg.reply(MTC_NO_RESPONSE_MESSAGE);
      return;
    }
    results1 = [];
    for (i = 0, len = results.length; i < len; i++) {
      stop = results[i];
      if (stop.Text.toLowerCase().match(stop_string.toLowerCase())) {
        stop_code = stop.Value.toString();
        stop_text = stop.Text.toString();
        results1.push(get_depart_time(msg, route, direction, stop_code, stop_text));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  });
};

get_depart_time = function(msg, route, direction, stop, stop_desc) {
  var direction_num, service_url;
  if (typeof direction !== Number) {
    direction_num = MTC_DIRECTIONS[direction];
  }
  service_url = MTC_API_URL + route + "/" + direction_num + "/" + stop + '?format=JSON';
  console.log("get_depart_time request: " + service_url);
  return msg.http(service_url).get()(function(err, res, body) {
    var res_description, res_diff, res_direction, res_stop, res_time, response, results;
    if (err || res.statusCode !== 200) {
      msg.reply(MTC_ERROR_MESSAGE + "(NexTrip response bad)");
      return;
    }
    results = JSON.parse(body);
    if (results.length === 0) {
      msg.reply(MTC_NO_RESPONSE_MESSAGE);
      return;
    }
    response = "";
    res_description = results[0].Description.toUpperCase();
    res_direction = results[0].RouteDirection;
    res_time = eval("new " + results[0].DepartureTime.slice(1, -1));
    res_diff = res_time - new Date(); //diff in ms
    res_diff = Math.floor(res_diff / 1000 / 60);
    if (stop_desc != null) {
      res_stop = "FROM " + stop_desc.toUpperCase() + " ";
    } else {
      res_stop = "";
    }
    console.log("get_depart_time parsed: ", res_description, res_direction, res_stop, res_time, res_diff);
    response = "THE NEXT " + res_description + " " + res_direction + " TRANSPORT " + res_stop + "DEPARTS IN " + res_diff.toString() + " MINUTES.";
    return msg.reply(response);
  });
};

get_depart_time_stopid = function(msg, route, direction, stopid) {
  var direction_num, service_url;
  if (typeof direction !== Number) {
    direction_num = MTC_DIRECTIONS[direction];
  }
  service_url = MTC_API_URL + stopid + '?format=JSON';
  console.log("get_depart_time_stopid request: " + service_url);
  return msg.http(service_url).get()(function(err, res, body) {
    var i, len, res_description, res_diff, res_direction, res_time, response, results, results1, stop;
    if (err || res.statusCode !== 200) {
      msg.reply(MTC_ERROR_MESSAGE + "(NexTrip response bad)");
      return;
    }
    results = JSON.parse(body);
    if (results.length === 0) {
      msg.reply(MTC_NO_RESPONSE_MESSAGE);
      return;
    }
    response = "";
    results1 = [];
    for (i = 0, len = results.length; i < len; i++) {
      stop = results[i];
      if (stop.Actual === true && stop.Route === route) {
        res_description = stop.Description.toUpperCase();
        res_direction = stop.RouteDirection;
        res_time = eval("new " + stop.DepartureTime.slice(1, -1));
        res_diff = Math.floor((res_time - new Date()) / 1000 / 60);
        console.log("get_depart_time_stopid parsed: ", res_description, res_direction, res_time, res_diff);
        results1.push(msg.reply("THE NEXT " + res_description + " " + res_direction + " TRANSPORT FROM STOPID " + stopid + " DEPARTS IN " + res_diff.toString() + " MINUTES."));
      } else {
        results1.push(void 0);
      }
    }
    return results1;
  });
};

module.exports = function(robot) {
  return robot.respond(/when is the next (.*) (bus|train) heading (.*) from (.*)/i, function(msg) {
    var route;
    if (msg.match[1].length > 3) {
      route = MTC_TRAINS[msg.match[1].toLowerCase()];
    } else {
      route = msg.match[1];
    }
    if (msg.match[4].length === 5) {
      get_depart_time_stopid(msg, route, msg.match[3], msg.match[4]);
    }
    if (msg.match[4].length === 4) {
      return get_depart_time(msg, route, msg.match[3], msg.match[4], null);
    } else {
      return get_stop_code(msg, route, msg.match[3], msg.match[4]);
    }
  });
};
